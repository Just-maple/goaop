// +build aopgen

package goaop

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
)

const aopTemplate = `

// {{ .Name }}
type {{ .Name }} struct {
	Origin {{ .Type }}
	InterceptorFactory aop.InterceptorFactory
}

func init(){
	aop.RegisterInterceptorProxy("{{ .Name }}",{{ .Name }}{})
}

func (this {{ .Name }}) RegisterInterceptor(origin interface{}, inceptorFactory aop.InterceptorFactory) interface{} {
	return &{{ .Name }}{
		Origin:       origin.({{ .Type }}),
		InterceptorFactory: inceptorFactory,
	}
}

{{ range $Method := .Methods}}
func (this *{{ $.Name }}) {{ $Method.Name }}({{ range $i,$v := .Param }}param_{{ $i }} {{ $v }},{{ end }}) ({{ .Ret }}){
	interceptor,ok := this.InterceptorFactory.InitInterceptor(&aop.JoinPoint{
		Method: this.Origin.{{ $Method.Name }},
		Params: []interface{}{ {{ range $i,$_ := .Param }} &param_{{ $i }},{{ end }} },
		Returns: []interface{}{ {{ range $i,$_ := .Return }} &ret_{{ $i }},{{ end }} },
	})
	if !ok {
		return
	}
	defer interceptor.Defer()
	{{ .RetRec }} {{ if .Ret }} = {{ end }} this.Origin.{{ $Method.Name }}({{ range $i,$v := .Param }}param_{{ $i }},{{ end }} )
	return
}

{{ end }}
`

var templateAop = template.Must(template.New("").Parse(aopTemplate))

const templateAopHead = `
// Code generated by goaop. DO NOT EDIT.
package aop

import (
	%s
)

`

type aopProxy struct {
	Name    string
	Type    string
	Methods []proxyMethod
}

type proxyMethod struct {
	Name   string
	Param  []string
	Return []string
	Ret    string
	RetRec string
}

func (p *parser) gen(path string) (err error) {
	ret := make(map[string][]string)
	importPath := make(map[string]map[string]bool)
	interfaceMap := make(map[string]proxyInterface)
	for _, face := range p.proxyInterfaces {
		interfaceMap[face.Name] = face
	}

	for _, face := range interfaceMap {
		interfaceType := face.Type
		depT := aopProxy{
			Name: face.Name,
			Type: face.Type.String(),
		}
		if importPath[face.ParentPkg] == nil {
			importPath[face.ParentPkg] = map[string]bool{
				face.Pkg:     true,
				importMyself: true,
			}
		}

		for i := 0; i < interfaceType.NumMethod(); i++ {
			mv := interfaceType.Method(i)
			depM := proxyMethod{
				Name: mv.Name,
			}
			for j := 0; j < mv.Type.NumIn(); j++ {
				inV := mv.Type.In(j)
				if len(inV.PkgPath()) > 0 {
					importPath[face.ParentPkg][inV.PkgPath()] = true
				}
				depM.Param = append(depM.Param, mv.Type.In(j).String())
			}

			var rets []string
			var retRecs []string
			for j := 0; j < mv.Type.NumOut(); j++ {
				outV := mv.Type.Out(j)
				if len(outV.PkgPath()) > 0 {
					importPath[face.ParentPkg][outV.PkgPath()] = true
				}
				depM.Return = append(depM.Return, outV.String())
				rets = append(rets, "ret_"+strconv.Itoa(j)+" "+outV.String())
				retRecs = append(retRecs, "ret_"+strconv.Itoa(j))
			}
			if len(rets) > 0 {
				depM.Ret = strings.Join(rets, ",")
				depM.RetRec = strings.Join(retRecs, ",")
			}
			depT.Methods = append(depT.Methods, depM)
		}
		bf := new(bytes.Buffer)
		err = templateAop.Execute(bf, depT)
		if err != nil {
			return
		}

		fmt.Printf("[GOAOP] generate [ %s ] interceptor proxy\n", face.Name)
		ret[face.ParentPkg] = append(ret[face.ParentPkg], bf.String())
	}

	for k, v := range ret {
		var strImports []string
		for p := range importPath[k] {
			strImports = append(strImports, strconv.Quote(p))
		}
		rawBytes := fmt.Sprintf(templateAopHead, strings.Join(strImports, "\n")) + strings.Join(v, "\n\n")
		var importsBytes []byte
		importsBytes, err = Process("", []byte(rawBytes), nil)
		if err != nil {
			return
		}
		_ = os.MkdirAll(filepath.Dir(path), 0775)
		err = ioutil.WriteFile(filepath.Join(path, k+".aop.go"), importsBytes, 0664)
		if err != nil {
			return
		}
	}
	return
}
